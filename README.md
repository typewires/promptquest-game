# PromptQuest
PromptQuest is an AI-driven content generator whose output is a playable mini-RPG.
The game is not the product. It exists to validate the generator.

Each generated game is a test harness and a concrete artifact proving the system works.
The focus is the generation pipeline and the properties it is designed to have: reliability, controllability, and cost-aware iteration from an underspecified prompt.

## What This Project Is / Is Not

### What This Project Is
- An AI-first generator that converts a single text prompt into a complete, playable adventure run (maps, quests, dialogue, sprites)
- A system combining procedural generation, LLM-generated narrative, and image generation into one pipeline
- A cost-aware, cache-backed generation pipeline designed to be reproducible per run and cheaper on reruns

### What This Project Is Not
- A handcrafted or content-heavy game
- An attempt to build a full RPG engine
- A showcase of deep level design, long-form progression, or a fully designed game

In practice, you type a short prompt like “a lantern-lit seaside town at dusk”, choose how many levels you want, and the generator produces:
- A run of **levels** (maps + vibe)
- **Characters** (player + NPCs)
- **Items + interactive props** (doors, chests, keys, shops, etc.)
- A **goal stack** per level (a quest log with progress UI)

Under the hood it’s a **Python** project:
- A tiny **Flask** web UI for entering your prompt + key and generating content
- A **Pygame** client that runs the actual game loop and rendering

Early versions generated nearly everything via AI. To keep the project practical and affordable to run, the generator now bakes a small set of core sprites and reuses them (including the shopkeeper, innkeeper, and the princess sick/healed cure pair), while continuing to generate the rest of the run so that no two runs are exactly the same.

## Quick Start

1. Create a virtual environment (recommended on macOS/Homebrew because system pip is “externally managed”):

```bash
python3 -m venv .venv
source .venv/bin/activate
python -m pip install --upgrade pip
pip install -r requirements.txt
```

2. Run the game generator:

```bash
python game_generator.py
```

3. Open the local page (shown in the terminal) and:
- Paste your `OPENAI_API_KEY`
- Enter a prompt
- Choose number of levels (1–3)
- Click **Generate**

Then return to the terminal and press **ENTER** to start playing.

## Per-Level Biome Control (UI + Prompt)
You can control biomes in either place:

- UI method:
  - In the generator page, each level card has its own `Level N biome` dropdown.
  - Example: set `Level 1 biome = snow`, `Level 2 biome = ruins`, `Level 3 biome = beach`.

- Prompt method:
  - Add directives like:
    - `Level 1 Biome: snow`
    - `Level 2 Biome: ruins`
    - `Level 3 Biome: beach`

- Priority rule:
  - Prompt biome directive overrides the UI biome for the same level.
  - If no biome is set in prompt or UI for a level, that level biome is auto-generated randomly from supported biomes.

- Under-specified runs:
  - If you generate 3 levels but only specify Level 1 biome, Level 2 and Level 3 biomes are auto-generated.

## How It Works (Simple)
Each level is produced in three layers:

1. Map (free, procedural)
Map layout, decor placement, and “vibe” are generated by code using a finite set of biomes/time-of-day/layout styles plus seeded randomness. Your prompt strongly influences which biome/time/layout is chosen.
2. Goal (free, sampled)
Each level plays a goal stack drawn from: `cure`, `key_and_door`, `lost_item`, `repair_bridge`. If you do not specify goals (UI or prompt), the generator chooses a single goal type per level by default.
3. Story + Sprites (AI)
Text AI generates names, dialogue, and quest steps. Image AI generates sprites, with cost controls via the Quality dropdown plus baked sprites and local disk caching.

## At A Glance 
When you press Generate, it produces a **new playable run** (levels + quests + sprites).

| Part | Where it comes from | What your prompt affects |
| --- | --- | --- |
| Map | Code (procedural + seeded) | Biome/time/layout/decor “vibe” |
| Goals | Code (fixed goal system; per-level stacks can be specified; otherwise sampled) | UI checkboxes and/or `Level N:` directives (otherwise the generator picks for you) |
| Dialogue + sprites | AI (text + image) with caching and baked assets | Character/item styling and flavor |

| Reuse vs new | What happens |
| --- | --- |
| Reused (to save cost) | Player sprite across levels, shopkeeper/innkeeper sprites across levels, plus baked core sprites if present (shop/inn NPCs, princess cure pair, key props) |
| New every run | Maps, placements, quest text, NPC names, and (optionally) some item sprites depending on Quality |

**Sprite load order (fastest to slowest)**: baked `assets/sprites/` → local disk cache `generated_sprites/` → image API.

## Example Prompt (Per-Level Goal Stacks)
Try pasting this into the prompt box:

```
A lantern-lit harbor town at night with wet cobblestone streets, crates by the docks, and a cozy inn.
Level 1: lost_item
Level 2: key_and_door
Level 3: repair_bridge
```

What you’ll typically get (varies run-to-run):
- Level 1 (lost_item): an NPC asks for a missing item; the item is somewhere on the map; return it to finish the level.
- Level 2 (key_and_door): a chest spawns; opening it reveals a key; the key unlocks a door.
- Level 3 (repair_bridge): a broken bridge blocks an area; buy materials in the shop; repair the bridge (visual changes) and cross.

## Controls
- `WASD` / Arrow keys: Move
- `SPACE`: Interact (talk, open, pick up, use)
- `1`, `2`, `3`: Buy options in shops (when you’re inside a shop)
- `N` / `ENTER`: Next level (after level objective is complete)
- `R`: Restart / replay the same generated run (after finishing the last level)
- `ESC`: Quit

## What Prompts Change
Prompts primarily influence the **setting and vibe**:
- Terrain style (forest/town/desert/ruins/castle/beach/snow, etc.)
- Time of day (day/dawn/sunset/night)
- Themed NPC + item flavor
- You can set biome per level in UI or prompt directives; if a level biome is not specified, it is randomized from supported biomes

Maps are procedurally generated from a finite set of biomes, time-of-day palettes, and layout styles, then varied by seeds and decor placement.

Goal types come from a **fixed allowed set** to keep gameplay reliable. Per level, the goal stack is determined in this order:
- Prompt directives override the UI for that same level
- Otherwise, UI checkboxes define the level’s goal stack
- Otherwise, only Level 1 may be inferred from prompt keywords
- Otherwise, the generator chooses a single goal type for that level

The AI fills in the flavor: names, dialogue, item descriptions, and visual style.

If you don’t specify goals, the game picks them and varies them across levels.

### Prompt → Map Matching
The game uses a mix of:
- AI output (terrain type/features returned by the world JSON)
- A prompt “hint extractor” (keyword-based) to strongly align the map with your prompt

If your prompt clearly implies a biome/time (e.g. “desert oasis at night”, “harbor town”, “ruined temple”), the generator will bias/override the terrain/time-of-day and add themed decor so the level looks distinct and on-theme.

### Theme Decor You Might See
Based on prompt keywords + biome, the map renderer can add extra themed decor such as:
- Desert: **cacti**, oasis-like water layouts
- Beach/harbor prompts: **shells**, coastline water bands, crates near paths
- Snow: **snow piles**
- Town/market/bazaar/port/harbor: **crates** and busier street layouts (`market_street`)
- Ruins/temple/castle: **statues** and **vines**, ruin-like layouts (`ruin_ring`)
- Forest + night/mushroom vibe: **mushrooms**

## Goal Types (And Exactly How They’re Selected)

**Allowed goal types** (hard-coded in `game_generator.py`):
- `cure`
- `key_and_door`
- `lost_item`
- `repair_bridge`

### How goal selection works (UI + prompt directives)
This version supports **up to 3 levels** per run.

You have three ways to influence each level’s goal stack:

1. **Per-level goal options (UI checkboxes)** (Goals per level, optional)
   - Each level has its own set of goal checkboxes.
   - If you check multiple goals under a level, those goals are **stacked** together for that level (you must complete all of them).
   - If you leave a level blank, it will be randomized from all allowed goals.
   - The generator tries to **avoid repeating** the same goal type across levels when possible.

2. **Per-level explicit goals (inside your prompt)** (Overrides UI for that level)
    - You can force goals with text like:
      - `Level 1: cure`
      - `Level 2: key_and_door`
      - `Level 3: repair_bridge`
    - If you specify a goal for a level in the prompt, that level will use it even if you clicked different goals in the UI.
    - You can also stack goals in the prompt, for example: `Level 2: cure, lost_item`

3. **Implicit goal (Level 1 only)** (Inferred from your prompt text)
   - If Level 1 isn’t explicitly set, the game may infer it from keywords:
     - “sick / cure / heal” → `cure`
     - “key / door / unlock” → `key_and_door`
     - “lost / missing / stolen” → `lost_item`
     - “bridge / repair” → `repair_bridge`
   - Inference is only used when it makes sense for the level’s available options.

### Prompt Directive Syntax (All Levels)
Recommended syntax:
- `Level 1: cure`
- `Level 2: cure, lost_item`
- `Level 3: repair_bridge`
- `Level 1 Biome: meadow | forest | town | beach | snow | desert | ruins | castle`
- `Level 2 Biome: meadow | forest | town | beach | snow | desert | ruins | castle`
- `Level 3 Biome: meadow | forest | town | beach | snow | desert | ruins | castle`

Allowed goal tokens:
- `cure`, `key_and_door`, `lost_item`, `repair_bridge`

These are optional. If you omit a level directive, that level’s goal stack will be chosen from your UI selections (or randomized if left blank).
If you omit a level biome directive and also leave that level biome blank in UI, the biome is randomly selected.

### Prompt + UI Examples
You can set the same controls in either place:
- UI: level count, quality, per-level goals, per-level biome, optional global time
- Prompt: explicit per-level directives plus style instructions

Three valid workflows:
- Simple prompt only: write a theme/vibe sentence and let the generator pick goals/biomes/details for each level.
- Manual UI control: select per-level biome and goals in UI, with little or no prompt directives.
- Fully specified prompt: use per-level directives (`Level N`, `Level N Biome`, `Time`) plus character style notes.

Example prompt with explicit per-level controls:

```text
A lantern-lit kingdom road with detailed 32-bit characters.
Time: night
Level 1 Biome: snow
Level 2 Biome: ruins
Level 3 Biome: beach
Level 1: cure
Level 2: lost_item
Level 3: key_and_door
Hero look: red scarf alchemist with dark blue coat and satchel.
NPC look: princess in pale gown, then healed and glowing.
```

How precedence works:
- If prompt and UI both set the same thing for the same level, prompt wins.
- If only UI sets it, UI is used.
- If neither prompt nor UI sets it, the generator randomizes from valid options.
- If you set only `Level 1 Biome` but generate 3 levels, Level 2 and Level 3 biomes/goals are auto-generated unless explicitly set.

Example:
- UI Level 2 biome = `forest`, but prompt says `Level 2 Biome: snow` → Level 2 uses `snow`.
- UI leaves Level 3 goals empty, and prompt has no `Level 3:` goal line → Level 3 goals are randomized.

Minimal prompt example (auto-generated details):

```text
A peaceful mountain kingdom under moonlight with warm inns and old stone roads.
```

Granular prompt example (manual per-level control):

```text
A lantern-lit fantasy world with high-detail character portraits.
Time: night
Level 1 Biome: snow
Level 2 Biome: ruins
Level 3 Biome: beach
Level 1: cure
Level 2: lost_item
Level 3: key_and_door
Hero look: red scarf alchemist, dark blue coat, satchel.
NPC look: sick princess in pale gown, healed version should look brighter.
```

## Cost / Quality Settings
The generator UI has a **Quality** dropdown:
- **Low (cheapest)**: `TEXT_MODEL=gpt-4o-mini`, `IMAGE_MODEL=gpt-image-1` with `quality=low`
- **Medium (default)**: `TEXT_MODEL=gpt-4o-mini`, `IMAGE_MODEL=gpt-image-1` with `quality=medium`
- **High (best)**: `TEXT_MODEL=gpt-4o`, `IMAGE_MODEL=gpt-image-1` with `quality=high`

### What the dropdown actually changes
- The dropdown is sent to the backend as `quality` in the `/generate` request.
- The server sets:
  - `Config.TEXT_MODEL` (for world/quest/dialogue JSON)
  - `Config.IMAGE_QUALITY` (for `gpt-image-1` sprite generation)

### Sprite reuse (fewer image calls)
To reduce cost within a multi-level run:
- The **player sprite** is reused across all levels (consistent protagonist).
- The **shop** and **inn** NPC sprites are generated once and reused across levels.

### Sprite caching (disk)
Sprite images are cached on disk so reruns can be much cheaper.
- Cache directory: `generated_sprites/`
- Cache key includes: image model, image quality, sprite role, and the prompt text for that sprite.
- If a cache hit exists, the game loads the `.png` from disk and skips the OpenAI image call.

Note: `generated_sprites/` is ignored by git by default (it’s a local cache).

## Pre-Generating Core Sprites (Optional, Recommended)
This project supports **baking** a small set of core sprites once at **High** quality and saving them into the repo. I recommend doing this (and I do this for the main repo) so the default experience has great-looking shop/inn/props with **fewer image API calls**.

If you fork this repo or make your own version, you can choose to bake your own core sprite set too. It’s optional. Everything still works without baking (the game will just generate those sprites via the image API instead).

### What Gets Baked
Exactly **12 PNGs + 1 manifest**:

- NPCs: `assets/sprites/npc_shop.png`, `assets/sprites/npc_inn.png`
- Princess cure pair: `assets/sprites/npc_princess_sick.png`, `assets/sprites/npc_princess_healed.png`
- Props: `assets/sprites/chest.png`, `assets/sprites/key.png`, `assets/sprites/door.png`, `assets/sprites/mix_station.png`
- Bridge materials: `assets/sprites/mat_planks.png`, `assets/sprites/mat_rope.png`, `assets/sprites/mat_nails.png`
- Generic item icon: `assets/sprites/item_generic.png`
- Manifest: `assets/sprites/manifest.json`

### What Is The Manifest?
`assets/sprites/manifest.json` is a small JSON file that maps **sprite keys** (like `npc_shop` or `chest`) to the **PNG filenames** to load. The game reads this file at startup so it knows which baked files to use.

### Bake command
From the repo root:

```bash
export OPENAI_API_KEY="sk-..."
python game_generator.py --bake-core --quality high
```

This writes PNGs to `assets/sprites/` and a `assets/sprites/manifest.json`.

### Commit and push baked sprites (maintainer workflow)
```bash
git add assets/sprites
git commit -m "Add baked core sprites (high quality)"
git push
```

### How “preloading” works at runtime
On every run, the game checks `assets/sprites/` first:
- If a baked sprite file exists for a key (via `assets/sprites/manifest.json`), it is loaded and used.
- If it’s missing, the game falls back to AI image generation (and/or disk cache).

## Quest Types (Examples)
Each level picks a goal stack (varied across the run):
- `cure`: Collect ingredients, mix a remedy, heal a sick NPC (NPC starts with a “sick” sprite and swaps to a “healed” sprite on completion).
- `key_and_door`: Find a chest, open it, get a key, unlock a door.
- `lost_item`: Search the map for a missing item and return it.
- `repair_bridge`: Visit a shop, buy materials (bridge planks/rope/nails) with in‑game money, then repair a broken bridge (visual changes from broken → fixed) to reach the objective.

## How To Complete Each Goal

### `cure` (Heal a Sick NPC)
What you’ll see:
- An NPC appears on the map in a “sick” state.
- A few ingredient items appear (collectibles).
- A mixing station appears (interactive).

How to finish:
1. Talk to the NPC (`SPACE`) to learn what’s wrong and what you need.
2. Collect the ingredients by walking over them / interacting (`SPACE`).
3. Use the mixing station (`SPACE`) once you have ingredients.
4. Return to the sick NPC and interact (`SPACE`) to heal them.
5. The NPC sprite swaps to a “healed” version and the quest completes.

### `key_and_door` (Chest → Key → Door)
What you’ll see:
- A closed chest, a locked door, and often a short hint from the NPC.

How to finish:
1. Find and open the chest (`SPACE`).
2. Pick up the key that appears.
3. Go to the door and unlock it (`SPACE`) to finish the level objective.

### `lost_item` (Find and Return)
What you’ll see:
- An NPC missing something.
- A “lost” item somewhere on the map.

How to finish:
1. Talk to the NPC (`SPACE`) to learn what’s missing.
2. Search the map for the item, then pick it up.
3. Return to the NPC and interact to complete the quest.

### `repair_bridge` (Shop → Buy Materials → Repair)
What you’ll see:
- A broken bridge area that blocks traversal.
- An enterable shop selling materials (planks/rope/nails).

How to finish:
1. Enter the shop and buy needed materials (see “Shops + Money” below).
2. Leave the shop and go to the broken bridge.
3. Interact at the bridge (`SPACE`) to repair it (if you have materials).
4. Cross the bridge and finish the level objective.

## Shops + Money
Some levels include enterable buildings (e.g., a shop/inn).
- Your money is shown in the UI.
- In a shop, press `SPACE` to talk to the shopkeeper and see buy instructions.
- Press `1`/`2`/`3` to buy items; the UI updates your remaining money and inventory.

### Entering and leaving buildings
- Approach a building’s **door** from outside.
- Press `SPACE` to enter.
- Inside, press `SPACE` near the door to exit back to the same outdoor map.

### How buying ties into goals
- `repair_bridge` uses the shop to sell required materials.
- Other goal types may still spawn shops (for flavor and future expansion), but `repair_bridge` is the one that currently depends on buying items.

### Inn Sleeping (Time Change)
The inn is also interactive:
- Walk up to a bed and press `SPACE` to rent a bed (costs gold).
- When you exit back outside, time toggles (`day ↔ night`) and the map palette updates.

## Repo Layout
- `game_generator.py`: everything (Flask UI + generator + Pygame engine)
- `generated_sprites/`: sprite cache (ignored by git)
- `.env.example`: example environment file (placeholder only)

## Troubleshooting

### `pip install` fails with “externally-managed-environment”
Use the virtualenv steps above (`python3 -m venv .venv` then install inside it).

### Browser shows a blank page
Make sure you’re visiting **HTTP**, not HTTPS:
- Use `http://127.0.0.1:5000` (not `https://...`).

### “Bad Request” in the terminal when you open the page
If you see `Bad request version` logs, it usually means your browser (or an extension) tried to speak **HTTPS** to the local **HTTP** server.
Use `http://127.0.0.1:5000` explicitly.

### Image generation errors (500s / 400s)
If the image API fails, the game may fall back to simple placeholder sprites. Re-run generation or try again later.

## License
Apache-2.0 (see `LICENSE`).
