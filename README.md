# PromptQuest (Work in progress..)
PromptQuest is an AI-driven content generator whose output is a playable mini-RPG.
The game is not the product. It exists to validate the generator.

Each generated game is a test harness and a concrete artifact proving the system works.
The focus is the generation pipeline and the properties it is designed to have: reliability, controllability, and cost-aware iteration from an underspecified prompt.

## What This Project Is / Is Not

### What This Project Is
- An AI-first generator that converts a single text prompt into a complete, playable adventure run (maps, quests, dialogue, sprites)
- A system combining procedural generation, LLM-generated narrative, and image generation into one pipeline
- A cost-aware, cache-backed generation pipeline designed to be reproducible per run and cheaper on reruns

### What This Project Is Not
- A handcrafted or content-heavy game
- An attempt to build a full RPG engine
- A showcase of deep level design, long-form progression, or a fully designed game

In practice, you type a short prompt like "a lantern-lit seaside town at dusk", choose how many levels you want, and the generator produces:
- A run of **levels** (maps + vibe)
- **Characters** (player + NPCs)
- **Items + interactive props** (doors, chests, keys, shops, etc.)
- A **goal stack** per level (a quest log with progress UI)

Under the hood it is a **Python** project:
- A tiny **Flask** web UI for entering your prompt + key and generating content
- A **Pygame** client that runs the actual game loop and rendering

Early versions generated nearly everything via AI. To keep the project practical and affordable to run, the generator now bakes a small set of core sprites and reuses them (including the shopkeeper, innkeeper, and the princess sick/healed cure pair), while continuing to generate the rest of the run so that no two runs are exactly the same.

## Quick Start

1. Create a virtual environment (recommended on macOS/Homebrew because system pip is externally managed):

```bash
python3 -m venv .venv
source .venv/bin/activate
python -m pip install --upgrade pip
pip install -r requirements.txt
```

2. Run the game generator:

```bash
python game_generator.py
```

3. Open the local page (shown in the terminal) and:
- Paste your `OPENAI_API_KEY`
- Enter a prompt
- Choose number of levels (1-3)
- Click **Generate**

Then return to the terminal and press **ENTER** to start playing.

## Per-Level Biome Control (UI + Prompt)
You can control biomes in either place:

- UI method:
  - In the generator page, each level card has its own `Level N biome` dropdown.
  - Example: set `Level 1 biome = snow`, `Level 2 biome = ruins`, `Level 3 biome = beach`.

- Prompt method:
  - Add directives like:
    - `Level 1 Biome: snow`
    - `Level 2 Biome: ruins`
    - `Level 3 Biome: beach`

- Priority rule:
  - Prompt biome directive overrides the UI biome for the same level.
  - If no biome is set in prompt or UI for a level, that level biome is auto-generated randomly from supported biomes.

- Under-specified runs:
  - If you generate 3 levels but only specify Level 1 biome, Level 2 and Level 3 biomes are auto-generated.

## How It Works (Simple)
Each level is produced in three layers:

1. Map (free, procedural)
Map layout, decor placement, and vibe are generated by code using a finite set of biomes/time-of-day/layout styles plus seeded randomness. Your prompt strongly influences which biome/time/layout is chosen.
2. Goal (free, sampled)
Each level plays a goal stack drawn from: `cure`, `key_and_door`, `lost_item`, `repair_bridge`. If you do not specify goals (UI or prompt), the generator auto-selects a valid random goal stack per level.
3. Story + Sprites (AI)
Text AI generates names, dialogue, and quest steps. Image AI generates sprites, with cost controls via the Quality dropdown plus baked sprites and local disk caching.

## At A Glance
When you press Generate, it produces a **new playable run** (levels + quests + sprites).

| Part | Where it comes from | What your prompt affects |
| --- | --- | --- |
| Map | Code (procedural + seeded) | Biome/time/layout/decor vibe |
| Goals | Code (fixed goal system; per-level stacks can be specified; otherwise sampled) | UI checkboxes and/or `Level N:` directives (otherwise the generator picks for you) |
| Dialogue + sprites | AI (text + image) with caching and baked assets | Character/item styling and flavor |

| Reuse vs new | What happens |
| --- | --- |
| Reused (to save cost) | Player sprite across levels, shopkeeper/innkeeper sprites across levels, plus baked core sprites if present (shop/inn NPCs, princess cure pair, key props) |
| New every run | Maps, placements, quest text, NPC names, and (optionally) some item sprites depending on Quality |

**Sprite load order (fastest to slowest)**: baked `assets/sprites/` -> local disk cache `generated_sprites/` -> image API.

## Prompt + UI Examples
You can set the same controls in either place:
- UI: level count, quality, per-level goals, per-level biome, optional global time
- Prompt: explicit per-level directives plus style instructions

Three valid workflows:
- Simple prompt only: write a theme/vibe sentence and let the generator pick goals/biomes/details for each level.
- Manual UI control: select per-level biome and goals in UI, with little or no prompt directives.
- Fully specified prompt: use per-level directives (`Level N`, `Level N Biome`, `Time`) plus character style notes.
- Prompt helper buttons in the UI include all 8 biomes (`meadow`, `forest`, `town`, `beach`, `snow`, `desert`, `ruins`, `castle`) and all times (`day`, `dawn`, `sunset`, `night`).

Example prompt with explicit per-level controls:

```text
A lantern-lit fantasy world with high-detail character portraits.
Level 1 Time: night
Level 2 Time: dawn
Level 3 Time: sunset
Level 1 Biome: snow
Level 2 Biome: ruins
Level 3 Biome: beach
Level 1 Quest NPC style: sick princess in a pale gown; goal is cure
Level 2 Quest NPC style: old archivist in cracked stone robes; goal is lost_item
Level 3 Quest NPC style: gate warden in a blue steel cloak; goal is key_and_door
Hero look: red scarf alchemist, dark blue coat, satchel.
```

Plain-language version of the same setup:

In a lantern-lit fantasy world with high-detail character portraits, Level 1 happens at night in snow with a cure objective for a sick princess. Level 2 happens at dawn in ruins with a lost-item objective tied to an old archivist in cracked stone robes. Level 3 happens at sunset on a beach with a key-and-door objective tied to a gate warden in a blue steel cloak. The hero should look like a red-scarf alchemist in a dark blue coat with a satchel.

How this is interpreted:
- The generator can infer intent from plain-language prompts (theme, likely goals, likely biome/time cues).
- For guaranteed per-level control, use explicit directives (`Level N`, `Level N Biome`, `Level N Time`, `goal is ...`).
- If you under-specify anything in prompt and UI, the generator fills missing values from valid options.

How precedence works:
- If prompt and UI both set the same thing for the same level, prompt wins.
- If only UI sets it, UI is used.
- If neither prompt nor UI sets it, the generator randomizes from valid options.
- If you set only `Level 1 Biome` but generate 3 levels, Level 2 and Level 3 biomes/goals are auto-generated unless explicitly set.
- Global `Time: ...`, `Hero look: ...`, and `NPC look: ...` are treated as Level 1 defaults. Levels 2/3 randomize those unless you provide per-level directives (for example `Level 2 Time: dawn` or `Level 2 Quest NPC style: ...`).
- The first line (for example `A lantern-lit fantasy world with high-detail character portraits.`) is global run context and applies to all levels.
- A `Level N Quest NPC style: ...` line affects the primary quest NPC for that level.
- It does not automatically force every NPC sprite in that level to use that same style.
- Shopkeeper/innkeeper are separate reused NPC roles and can look different from the quest NPC.

Example:
- UI Level 2 biome = `forest`, but prompt says `Level 2 Biome: snow` -> Level 2 uses `snow`.
- UI leaves Level 3 goals empty, and prompt has no `Level 3:` goal line -> Level 3 goals are randomized.

Minimal prompt example (auto-generated details):

```text
A peaceful mountain kingdom under moonlight with warm inns and old stone roads.
```

## Cost / Quality Settings
The generator UI has a **Quality** dropdown:
- **Low (cheapest)**: `TEXT_MODEL=gpt-4o-mini`, `IMAGE_MODEL=gpt-image-1` with `quality=low`
- **Medium (default)**: `TEXT_MODEL=gpt-4o-mini`, `IMAGE_MODEL=gpt-image-1` with `quality=medium`
- **High (best)**: `TEXT_MODEL=gpt-4o`, `IMAGE_MODEL=gpt-image-1` with `quality=high`

### What the dropdown actually changes
- The dropdown is sent to the backend as `quality` in the `/generate` request.
- The server sets:
  - `Config.TEXT_MODEL` (for world/quest/dialogue JSON)
  - `Config.IMAGE_QUALITY` (for `gpt-image-1` sprite generation)

### Sprite reuse (fewer image calls)
To reduce cost within a multi-level run:
- The **player sprite** is reused across all levels (consistent protagonist).
- The **shop** and **inn host** NPC sprites are generated once and reused across levels.

Reuse decision order for recurring NPC roles:
- If a baked sprite exists in `assets/sprites/manifest.json`, it is used.
- Else, if a prior level already generated that role (`npc_shop` / `npc_inn`), that image is reused.
- Else, a new image is generated once, then reused for later levels in the same run.

### Sprite caching (disk)
Sprite images are cached on disk so reruns can be much cheaper.
- Cache directory: `generated_sprites/`
- Cache key includes: image model, image quality, sprite role, and the prompt text for that sprite.
- If a cache hit exists, the game loads the `.png` from disk and skips the OpenAI image call.
- Terrain preview tiles are also cached locally in `generated_terrain_tiles/` for faster redraws.

Note: `generated_sprites/` is ignored by git by default (it is a local cache).

## Pre-Generating Core Sprites (Optional, Recommended)
This project supports baking a small set of core sprites once at **High** quality and saving them into the repo. This gives a better default visual baseline with fewer image API calls.

If you fork this repo or make your own version, you can choose to bake your own core sprite set too. It is optional. Everything still works without baking (the game will generate those sprites via the image API instead).

### What Gets Baked
Current baked assets in this repo are:

- NPCs: `assets/sprites/npc_shop.png`, `assets/sprites/npc_inn.png`
- Princess cure pair files: `assets/sprites/npc_princess_sick.png`, `assets/sprites/npc_princess_healed.png`
- Props: `assets/sprites/chest.png`, `assets/sprites/key.png`, `assets/sprites/door.png`, `assets/sprites/mix_station.png`
- Bridge materials: `assets/sprites/mat_planks.png`, `assets/sprites/mat_rope.png`, `assets/sprites/mat_nails.png`
- Generic item icon: `assets/sprites/item_generic.png`
- Manifest: `assets/sprites/manifest.json`

Note: bridge state files (`bridge_broken.png`, `bridge_fixed.png`) are optional and not required by the current renderer.

### What Is The Manifest?
`assets/sprites/manifest.json` maps sprite keys (for example `npc_shop` or `chest`) to PNG filenames. The game reads this file at startup to know which baked files to load.

### Bake command
From the repo root:

```bash
export OPENAI_API_KEY="sk-..."
python game_generator.py --bake-core --quality high
```

This writes PNGs to `assets/sprites/` and updates `assets/sprites/manifest.json`.

### Commit and push baked sprites (maintainer workflow)
```bash
git add assets/sprites
git commit -m "Add baked core sprites"
git push
```

### How preloading works at runtime
On every run, the game checks `assets/sprites/` first:
- If a baked sprite file exists for a key (via `assets/sprites/manifest.json`), it is loaded and used.
- If it is missing, the game falls back to AI image generation (and/or disk cache).

## Quest Types (Examples)
Each level picks a goal stack (varied across the run):
- `cure`: Collect ingredients, mix a remedy, heal a sick NPC (NPC starts with a sick sprite and swaps to a healed sprite on completion).
- `key_and_door`: Find a chest, open it, get a key, unlock a door.
- `lost_item`: Search the map for a missing item and return it.
- `repair_bridge`: Visit a shop, buy materials (bridge planks/rope/nails) with in-game money, then repair a broken bridge (visual changes from broken to fixed) to reach the objective.

## How To Complete Each Goal

### `cure` (Heal a Sick NPC)
What you will see:
- An NPC appears on the map in a sick state.
- A few ingredient items appear (collectibles).
- A mixing station appears (interactive).

How to finish:
1. Talk to the NPC (`SPACE`) to learn what is wrong and what you need.
2. Collect the ingredients by walking over them / interacting (`SPACE`).
3. Use the mixing station (`SPACE`) once you have ingredients.
4. Return to the sick NPC and interact to heal them.
5. The NPC sprite swaps to a healed version and the quest completes.

### `key_and_door` (Chest -> Key -> Door)
What you will see:
- A closed chest, a locked door, and often a short hint from the NPC.

How to finish:
1. Find and open the chest (`SPACE`).
2. Pick up the key that appears.
3. Go to the door and unlock it (`SPACE`) to finish the level objective.

### `lost_item` (Find and Return)
What you will see:
- An NPC missing something.
- A lost item somewhere on the map.

How to finish:
1. Talk to the NPC (`SPACE`) to learn what is missing.
2. Search the map for the item, then pick it up.
3. Return to the NPC and interact to complete the quest.

### `repair_bridge` (Shop -> Buy Materials -> Repair)
What you will see:
- A broken bridge area that blocks traversal.
- An enterable shop selling materials (planks/rope/nails).

How to finish:
1. Enter the shop and buy needed materials (see Shops + Money below).
2. Leave the shop and go to the broken bridge.
3. Interact at the bridge (`SPACE`) to repair it (if you have materials).
4. Cross the bridge and finish the level objective.

## Shops + Money
Some levels include enterable buildings (for example a shop/inn).
- Your money is shown in the UI.
- In a shop, press `SPACE` to talk to the shopkeeper and see buy instructions.
- Press `1`/`2`/`3` to buy items; the UI updates your remaining money and inventory.
- Shop visuals are shelf-based (items are displayed on different shelves rather than floor piles).

### Entering and leaving buildings
- Approach a building door from outside.
- Press `SPACE` to enter.
- Inside, press `SPACE` near the door to exit back to the same outdoor map.

### How buying ties into goals
- `repair_bridge` uses the shop to sell required materials.
- Other goal types may still spawn shops (for flavor and future expansion), but `repair_bridge` is the one that currently depends on buying items.

### Inn Sleeping (Time Change)
The inn has a two-step flow:
- Step 1: lobby check-in at the front desk (`SPACE` near inn host). Paying unlocks your numbered room.
- Step 2: go to the room door in the lobby and enter your private room.
- In the room, interact near the bed to sleep (same sleep logic as before, with early wake on `SPACE`).
- After sleep, time still toggles (`day` <-> `night`) and the outdoor palette updates.
- The inn lobby includes additional guest NPCs for ambient dialogue.

## Repo Layout
- `game_generator.py`: everything (Flask UI + generator + Pygame engine)
- `generated_sprites/`: sprite cache (ignored by git)
- `.env.example`: example environment file (placeholder only)

## Troubleshooting

### `pip install` fails with externally managed environment
Use the virtualenv steps above (`python3 -m venv .venv` then install inside it).

### Browser shows a blank page
Make sure you are visiting **HTTP**, not HTTPS:
- Use `http://127.0.0.1:5000` (not `https://...`).

### Bad Request in the terminal when you open the page
If you see `Bad request version` logs, it usually means your browser (or an extension) tried to speak **HTTPS** to the local **HTTP** server.
Use `http://127.0.0.1:5000` explicitly.

### Image generation errors (500s / 400s)
If the image API fails, the game may fall back to simple placeholder sprites. Re-run generation or try again later.

## License
Apache-2.0 (see `LICENSE`).
